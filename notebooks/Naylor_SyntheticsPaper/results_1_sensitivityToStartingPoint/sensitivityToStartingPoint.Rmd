---
title: "temporal_injection_ETAS_dev.Rmd"
author: "Naylor"
date: "2022-10-27"
output: html_document
---

# Multiple analyses of two catalogues using different initial values

The inlabru algorithm takes an initial guess on the mode of the parameters we are inverting for and iteratively updates this initial guess. There is the potential that there may be bad initial conditions such that they find different solutions and the runtime will differ depending upon how the solution converges.

In this notebook, we explore the robustness of the posteriors on two synthetic catalogues where the true parameters are known. Both catalogues contain 2000 days of data. One catalogue does not contain a large event and the second contains a M6.7 event on day 1000.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ETAS.inlabru)

library(tidyquant)
library(gridExtra)
library(grid)
library(lemon)
library(ggplot2)

library(inlabru)
library(INLA)

library(dplyr)

```


## Define the parameters for the syntheirc catalogues and starting values for inversion

```{r Create synthetic catalogue and plot}

# Parameters we use to generate synthetics, which we will refer to as the 'true' parameters
mu <- 0.1
K <- 0.089
alpha <- 2.29
c <- 0.11
p <- 1.08

# Format the true ETAS parameters for code to generate the synthetics
theta_etas <- data.frame(mu=mu, K=K, alpha=alpha, c=c, p=p)

# A dataframe containing different starting values for the algorithm
startingValues <- data.frame( mu=c(0.05, 5., mu, 0.3),
                              K=c(0.01, 1., K, 0.1),
                              alpha=c(1., 5., alpha, 1.),
                              c=c(0.05, 0.3, c, 0.2),
                              p=c(1.01, 1.5, p, 1.01))
nRealisations <- length(startingValues$mu)


# Temporal duration of the synthetic catalogue in days
modelledDuration = 1000  # [days]

# The minimum magnitude that will be modelled
M0 = 2.5

```

## Generate new catalogues and save them

```{r}
############
#### Generate the first catalogue with no large events

samp.etas.list <- generate.temporal.ETAS.synthetic(theta = theta_etas, 
                      beta.p = log(10), M0 = M0,  T1 = 0, T2 = modelledDuration, Ht=NULL)

quiet.ETAS.cat <- bind_rows(samp.etas.list)
quiet.ETAS.cat <- quiet.ETAS.cat[order(quiet.ETAS.cat$ts),]

```

```{r}

############
#### Generate the second catalogue with a M6.7 event on day 1000

Ht <- data.frame(ts=c(500), magnitudes=c(6.7))   # Impose a M6.7 event on day 1000

samp.etas.list <- generate.temporal.ETAS.synthetic(theta = theta_etas, beta.p = log(10), M0 = M0, T1 = 0, T2 = modelledDuration, Ht=Ht)

M6p7.ETAS.cat <- bind_rows(samp.etas.list)
M6p7.ETAS.cat <- M6p7.ETAS.cat[order(M6p7.ETAS.cat$ts),]

```

```{r}
save(M6p7.ETAS.cat,file="M6p7_ETAS_cat.Rda")
save(quiet.ETAS.cat,file="quiet.ETAS.cat.Rda")
```

# Present the catalogues

## Load the catalogues

```{r}
load("M6p7_ETAS_cat.Rda")
load("quiet.ETAS.cat.Rda")
```

## Plot properties of the catalogues

```{r}
plots <-list()

plots[[1]] <- ggplot() + 
  geom_point(data = quiet.ETAS.cat, aes(x=ts, y=magnitudes), size=0.1, alpha=0.5) +
  xlim(0, modelledDuration) +
  ggtitle(paste("(a) Quiet syntheic catalogue, nEvents =", length(quiet.ETAS.cat$ts) )) +
  ylim(2,7) +
  xlab("Time [days]") +
  ylab("Magnitude") + 
  theme_linedraw()

plots[[2]] <- ggplot() + 
  geom_point(data = M6p7.ETAS.cat, aes(x=ts, y=magnitudes), size=0.1, alpha=0.5) +
  xlim(0, modelledDuration) +
  ggtitle(paste("(b) Catalogue with M6.7 event on day 1000, nEvents =", length(M6p7.ETAS.cat$ts) )) +
  ylim(2,7) +
  xlab("Time [days]") +
  ylab("Magnitude") + 
  theme_linedraw()

marrangeGrob(plots, nrow=2, ncol=1)

ggsave("initialConditionCats.png", marrangeGrob(plots, nrow=2, ncol=1))
```

# Analyse the sensitivity to starting conditions

## Analysis of quiet catalogue

```{r}
list.output.quietScenario <-list()

for (i in 1:nRealisations){
  remove(list.input)

  # Load a set of parameters that we will need to tweak for this application
fpath <- system.file("extdata", "user_input_synthetic_noCatalogue.txt", package="ETAS.inlabru")
list.input <- create.input.list.temporal.noCatalogue(fpath)
  
  ####################
  # Tweak the variables laoded from the input file
  list.input$M0 <- M0
  list.input$time.int <- c(0, modelledDuration)
  list.input$T12 <- c(0, modelledDuration)
  
  # Change the starting location, measured on the ETAS scale
  list.input$mu.init <- startingValues$mu[i]
  list.input$alpha.init <- startingValues$alpha[i]
  list.input$K.init <- startingValues$K[i]
  list.input$c.init <- startingValues$c[i]
  list.input$p.init <- startingValues$p[i]

    link.f <- list(mu = \(x) gamma.t(x, a_mu, b_mu), 
                 K = \(x) loggaus.t(x, a_K, b_K), 
                 alpha = \(x) unif.t(x, a_alpha, b_alpha), 
                 c_ = \(x) unif.t(x, a_c, b_c), 
                 p = \(x) unif.t(x, a_p, b_p))
  
  # initial value - convert from ETAS scale to internal scale
  list.input$th.init <- list(th.mu = inv.gamma.t(list.input$mu.init, list.input$a_mu, list.input$b_mu),
                  th.K = inv.loggaus.t(list.input$K.init, list.input$a_K, list.input$b_K),
                  th.alpha = inv.unif.t(list.input$alpha.init, list.input$a_alpha, list.input$b_alpha),
                  th.c = inv.unif.t(list.input$c.init, list.input$a_c, list.input$b_c),
                  th.p = inv.unif.t(list.input$p.init, list.input$a_p, list.input$b_p) )

  # Define options for inlabru 
  if(is.null(list.input$max_step)){
    list.input$bru.opt.list <- list(bru_verbose = 3, # type of visual output 
                         bru_max_iter = list.input$max_iter, # maximum number of iterations
                         num.threads = 5,
                         #bru_method = list(max_step = 0.5),
                         inla.mode = 'experimental', # type of inla algorithm
                         bru_initial = list.input$th.init) # parameters initial values
  } else {
    list.input$bru.opt.list <- list(bru_verbose = 3, # type of visual output 
                         bru_max_iter = list.input$max_iter, # maximum number of iterations
                         bru_method = list(max_step = list.input$max_step),
                         num.threads = 5,
                         inla.mode = 'experimental', # type of inla algorithm
                         bru_initial = list.input$th.init) # parameters initial values
  }

  ## Add out catalogue to the input list
  list.input$catalog <- data.frame( 
      time_diff = quiet.ETAS.cat$ts,
      magnitudes = quiet.ETAS.cat$magnitudes
    )
  
  ## Add the catalogue formatted for bru
  list.input$catalog.bru <- data.frame(
    ts = quiet.ETAS.cat$ts,
    magnitudes = quiet.ETAS.cat$magnitudes,
    idx.p = seq_len(nrow(quiet.ETAS.cat))
  )
  
  ## Input list is now formatted
  ####################  
  
  ## Run the model according to the input list
  ETAS.model.fit <- Temporal.ETAS.fit(list.input)

  ## Small bit of post processing
  list.output.quietScenario[[i]] <- append(list.input, list(model.fit = ETAS.model.fit))
  list.output.quietScenario[[i]]$runtime <- sum(list.output.quietScenario[[i]]$model.fit$bru_timings$Time)
  list.output.quietScenario[[i]]$nEvents <- length(list.output.quietScenario[[i]]$catalog[,1])
}
```

## Analysis of M6.7 catalogue

```{r}
list.output.M6p7Scenario <-list()

for (i in 2:nRealisations){
  if(exists("list.input")) {remove(list.input)}

  # Load a set of parameters that we will need to tweak for this application
fpath <- system.file("extdata", "user_input_synthetic_noCatalogue.txt", package="ETAS.inlabru")
list.input <- create.input.list.temporal.noCatalogue(fpath)
  
  ####################
  # Tweak the variables laoded from the input file
  list.input$M0 <- M0
  list.input$time.int <- c(0, modelledDuration)
  list.input$T12 <- c(0, modelledDuration)
  
  # Change the starting location, measured on the ETAS scale
  list.input$mu.init <- startingValues$mu[i]
  list.input$alpha.init <- startingValues$alpha[i]
  list.input$K.init <- startingValues$K[i]
  list.input$c.init <- startingValues$c[i]
  list.input$p.init <- startingValues$p[i]

    link.f <- list(mu = \(x) gamma.t(x, a_mu, b_mu), 
                 K = \(x) loggaus.t(x, a_K, b_K), 
                 alpha = \(x) unif.t(x, a_alpha, b_alpha), 
                 c_ = \(x) unif.t(x, a_c, b_c), 
                 p = \(x) unif.t(x, a_p, b_p))
  
  # initial value - convert from ETAS scale to internal scale
  list.input$th.init <- list(th.mu = inv.gamma.t(list.input$mu.init, list.input$a_mu, list.input$b_mu),
                  th.K = inv.loggaus.t(list.input$K.init, list.input$a_K, list.input$b_K),
                  th.alpha = inv.unif.t(list.input$alpha.init, list.input$a_alpha, list.input$b_alpha),
                  th.c = inv.unif.t(list.input$c.init, list.input$a_c, list.input$b_c),
                  th.p = inv.unif.t(list.input$p.init, list.input$a_p, list.input$b_p) )

  # Define options for inlabru 
  if(is.null(list.input$max_step)){
    list.input$bru.opt.list <- list(bru_verbose = 3, # type of visual output 
                         bru_max_iter = list.input$max_iter, # maximum number of iterations
                         num.threads = 5,
                         #bru_method = list(max_step = 0.5),
                         inla.mode = 'experimental', # type of inla algorithm
                         bru_initial = list.input$th.init) # parameters initial values
  } else {
    list.input$bru.opt.list <- list(bru_verbose = 3, # type of visual output 
                         bru_max_iter = list.input$max_iter, # maximum number of iterations
                         bru_method = list(max_step = list.input$max_step),
                         num.threads = 5,
                         inla.mode = 'experimental', # type of inla algorithm
                         bru_initial = list.input$th.init) # parameters initial values
  }

  ## Add out catalogue to the input list
  list.input$catalog <- data.frame( 
      time_diff = M6p7.ETAS.cat$ts,
      magnitudes = M6p7.ETAS.cat$magnitudes
    )
  
  ## Add the catalogue formatted for bru
  list.input$catalog.bru <- data.frame(
    ts = M6p7.ETAS.cat$ts,
    magnitudes = M6p7.ETAS.cat$magnitudes,
    idx.p = seq_len(nrow(M6p7.ETAS.cat))
  )
  
  ## Input list is now formatted
  ####################  
  
  ## Run the model according to the input list
  ETAS.model.fit <- Temporal.ETAS.fit(list.input)

  ## Small bit of post processing
  list.output.M6p7Scenario[[i]] <- append(list.input, list(model.fit = ETAS.model.fit))
  list.output.M6p7Scenario[[i]]$runtime <- sum(list.output.M6p7Scenario[[i]]$model.fit$bru_timings$Time)
  list.output.M6p7Scenario[[i]]$nEvents <- length(list.output.M6p7Scenario[[i]]$catalog[,1])
}
```

### Plot posteriors with corresponding starting values

```{r}
plots <- list()

trueParas <- data.frame(value=c( mu, K, alpha,c, p), param=c( "mu", "K", "alpha","c", "p"))

post.list <- get_posterior_param(input.list = list.output.quietScenario[[1]])
post.df <-  post.list[[1]]
post.df$id <-1
 
for(i in 2:nRealisations){
 post.list <- get_posterior_param(input.list = list.output.quietScenario[[i]])
 post.df.tmp <-  post.list[[1]]
 post.df.tmp$id <-i
 
 post.df <- rbind(post.df,post.df.tmp)
 }

plots[[1]] <- ggplot(post.df, aes(x=x,y=y, group=id, color=factor(id), lty=factor(id))) + 
    geom_line() +
  #scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) + 
    facet_wrap(facets = vars(param), scales = 'free', labeller = label_parsed, nrow=1) +
  geom_vline(aes(xintercept = value ), data=trueParas, color='black', linetype=2, label="True value") + 
  labs(color='Initial ETAS Para. Set', linetype='Initial ETAS Para. Set' ) +
  ggtitle(paste("Inversion of a 1000 day catalogue with no large events, nEvents =",length(quiet.ETAS.cat$ts )) ) +
  xlab("ETAS Posteriors") + 
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  theme(legend.position='hidden') 

```

```{r}
trueParas <- data.frame(value=c( mu, K, alpha,c, p), param=c( "mu", "K", "alpha","c", "p"))

post.list <- get_posterior_param(input.list = list.output.M6p7Scenario[[2]])
post.df <-  post.list[[1]]
post.df$id <-2
 
for(i in 3:nRealisations){
 post.list <- get_posterior_param(input.list = list.output.M6p7Scenario[[i]])
 post.df.tmp <-  post.list[[1]]
 post.df.tmp$id <-i
 
 post.df <- rbind(post.df,post.df.tmp)
 }

plots[[2]] <- ggplot(post.df, aes(x=x,y=y, group=id, color=factor(id), lty=factor(id))) + 
    geom_line() +
  #scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) + 
    facet_wrap(facets = vars(param), scales = 'free', labeller = label_parsed, nrow=1) +
  geom_vline(aes(xintercept = value ), data=trueParas, color='black', linetype=2, label="True value") + 
  labs(color='Initial ETAS Para. Set', linetype='Initial ETAS Para. Set' ) +
  ggtitle(paste("Inversion of a 1000 day catalogue with a M6.7 on day 500, nEvents =", length(M6p7.ETAS.cat$ts )) ) +
  xlab("ETAS Posteriors") + 
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  theme(legend.position='hidden') 

```


```{r}
marrangeGrob(plots, nrow=2, ncol=1)

ggsave("initialCondition_posteriors.png", marrangeGrob(plots, nrow=2, ncol=1))

```

```{r}
grid_arrange_shared_legend(plots[[1]], plots[[2]], ncol=1, nrow=2, position='bottom')
```
## Explore ETAS triggering function using posterior samples

```{r}
plot_triggering <- list()
plot_triggering[[1]] <- triggering_fun_plot(list.output.quietScenario[[2]], magnitude = 4, n.samp = 100) +
ggtitle("(a) Quiecent posteriors; M4 event")+     theme_bw()  + ylim(0,5.5)


plot_triggering[[2]] <- triggering_fun_plot(list.output.M6p7Scenario[[2]], magnitude = 4, n.samp = 100)+
ggtitle("(b) M6.7 posteriors; M4 event")+     theme_bw()  + ylim(0,5.5)

plot_triggering[[3]] <- triggering_fun_plot(list.output.quietScenario[[2]], magnitude = 6.7, n.samp = 100) +
ggtitle("(c) Quiecent posteriors; M6.7 event")+     theme_bw()    + ylim(0,1700)


plot_triggering[[4]] <- triggering_fun_plot(list.output.M6p7Scenario[[2]], magnitude = 6.7, n.samp = 100)+
ggtitle("(d) M6.7 posteriors; M6.7 event")+     theme_bw()  + ylim(0,1700)


plt <- grid.arrange(plot_triggering[[1]], plot_triggering[[3]],plot_triggering[[2]], plot_triggering[[4]], ncol=2, nrow=2, top="Triggering function variability")

ggsave("trigFuncVariability_runin.png", plt)
```

```{r}
omori <- function(th, t, ti){
  output <- rep(0,length(t))
  t.diff <- t - ti
  neg <- t.diff <= 0
  if(sum(!neg) > 0){
    log.out <- - th[5]*log(1 + t.diff[!neg]/th[4])
    output[!neg] <- exp(log.out)
  }
  else{
    output
  }
  output
}
```


```{r}
plot_omori <- list()
plot_omori[[1]] <- omori_plot(list.output.quietScenario[[2]], n.samp = 20) +
ggtitle("(a) Quiecent posteriors; M4 event")+     theme_bw()  + ylim(0,1)


plot_omori[[2]] <- omori_plot(list.output.M6p7Scenario[[2]], n.samp = 20)+
ggtitle("(b) M6.7 posteriors; M4 event")+     theme_bw()  + ylim(0,1)



plt <- grid.arrange(plot_omori[[1]], plot_omori[[2]], ncol=1, nrow=2, top="Triggering function variability")

ggsave("trigFuncVariability_runin.png", plt)
```
